# 运算符


###1.1  算术运算符

```go
+ - * / %(求余) ++ --
```


算术运算符：+，-，*，/,%,++,--
/,取商
%,取余，取模

++，自赠1
--，自减1
 
 ```
 a := 10
 b := 3
 mul := a * b
 fmt.Println(mul)
 div := a / b //取商
 mod := a % b//取余，取模
 fmt.Println(div,mod)

 m := 3
 fmt.Println(m) //3
 m++ //自增加1
 fmt.Println(m)//4
 m-- //自减1
 fmt.Println(m)
 ```

###1.2 关系运算符

```go
== != > < >= <=
```

关系运算符：结果是bool类型
	>,<,>=,<=,==
	==,比较数值是否相等
	!=,比较数值是否不等

 ```
 a := 3
 b := 5
 c := 3
 fmt.Println(a > b,a > c)
 fmt.Println(a <= b,a <= c)

 fmt.Println(a == b)
 fmt.Println(a == c)
 fmt.Println(a != b)
 fmt.Println(a != c)
```
###1.3 逻辑运算符

| 运算符  | 描述                                       |
| ---- | ---------------------------------------- |
| &&   | 所谓逻辑与运算符。如果两个操作数都非零，则条件变为真               |
| \|\| | 所谓的逻辑或操作。如果任何两个操作数是非零，则条件变为真             |
| !    | 所谓逻辑非运算符。使用反转操作数的逻辑状态。如果条件为真，那么逻辑非操后结果为假 |


逻辑运算符：操作数必须是bool，运算结果也是bool
逻辑与：&&
		运算规则：所有的操作数都为真，结果才为真，有一个为假，就为假。
			"一假则假，全真才真"
逻辑或：||
		运算规则：所有的操作数都为假，结果就为假，有一个为真，就为真
			"一真则真，全假为假"
逻辑非：!
		运算规则：!T-->F,!F-->T
 
```
 f1 := true
 f2 := false
 f3 := true

 res1 := f1 && f2 && f3
 fmt.Println(res1)

 res2 := f1 || f2 || f3
 fmt.Println(res2)

 fmt.Println(f1,!f1)
 fmt.Println(f2,!f2)

 a := 3
 b := 2
 c := 5
 res3 := a > b && c % a == b && a < (c / b)

 res4 := b * 2 < c || a / b != 0 || c / a > b
 res5 := !(c / a == b)
 fmt.Println(res3,res4,res5)
 ```
 
###1.4 位运算符

| A    | B    | A&B  | A\|B | A^B  |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    |
| 0    | 1    | 0    | 1    | 1    |
| 1    | 1    | 1    | 1    | 0    |
| 1    | 0    | 0    | 1    | 1    |

这里最难理解的就是^了，只要认为AB两者都相同的时候，为0，其他都为1

假设A为60，B为13

| 运算   | 描述                                | 示例                                 |
| ---- | --------------------------------- | ---------------------------------- |
| &    | 二进制与操作副本位的结果，如果它存在于两个操作数          | (A & B) = 12, 也就是 0000 1100        |
| \|   | 二进制或操作副本，如果它存在一个操作数               | (A \| B) = 61, 也就是 0011 1101       |
| ^    | 二进制异或操作副本，如果它被设置在一个操作数但不能同时是比特    | (A ^ B) = 49, 也就是 0011 0001        |
| <<   | 二进制左移位运算符。左边的操作数的值向左移动由右操作数指定的位数  | A << 2 will give 240 也就是 1111 0000 |
| >>   | 二进制向右移位运算符。左边的操作数的值由右操作数指定的位数向右移动 | A >> 2 = 15 也就是 0000 1111          |


> 位运算符：了解性
	将数值，转为二进制后，按位操作
	按位&，
		位的值如果都为1才为1,有一个为0就为0
	按位|，
		位的值如果都为0才为0,有一个为1就为1
	异或^，
		不同为1,相同为0

位移运算符：
>	<<：按位左移,将a转为二进制，向左移动b位
	a << b
	>>：按位右移，将a转为二进制，向右移动b位
	a >> b
   
```
c := 8 
res4 := c << 2
fmt.Println(res4)
res5:=c >> 2
fmt.Println(res5)
```


### 1.5 赋值运算符

| 运算符  | 描述                               | 示例                                |
| ---- | -------------------------------- | --------------------------------- |
| =    | 简单的赋值操作符，分配值从右边的操作数左侧的操作数        | C = A + B 将分配A + B的值到C            |
| +=   | 相加并赋值运算符，它增加了右操作数左操作数和分配结果左操作数   | C += A 相当于 C = C + A              |
| -=   | 减和赋值运算符，它减去右操作数从左侧的操作数和分配结果左操作数  | C -= A 相当于 C = C - A              |
| *=   | 乘法和赋值运算符，它乘以右边的操作数与左操作数和分配结果左操作数 | C *= A is equivalent to C = C * A |
| /=   | 除法赋值运算符，它把左操作数与右操作数和分配结果左操作数     | C /= A 相当于 C = C / A              |
| %=   | 模量和赋值运算符，它需要使用两个操作数的模量和分配结果左操作数  | C %= A 相当于 C = C % A              |
| <<=  | 左移位并赋值运算符                        | C <<= 2 相同于 C = C << 2            |
| >>=  | 向右移位并赋值运算符                       | C >>= 2 相同于 C = C >> 2            |
| &=   | 按位与赋值运算符                         | C &= 2 相同于 C = C & 2              |
| ^=   | 按位异或并赋值运算符                       | C ^= 2 相同于 C = C ^ 2              |
| \|=  | 按位或并赋值运算符                        | C \|= 2 相同于 C = C \| 2            |


赋值运算符：=,+=,-=,*=,/=,%=,<<=,>>=,....
a = 3,将=右侧的数值，赋值给=左侧的变量

```
var a int
a = 3
fmt.Println(a)//3

a += 2 //相当于a = a + 2
fmt.Println(a)//5

a /= 3 //a =a /3
fmt.Println(a)//1

a %= 1 //
fmt.Println(a)
```

### 1.6优先级

运算符优先级
有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：

| 优先级  | 运算符              |
| ---- | ---------------- |
| 7    | ^ !              |
| 6    | * / % << >> & &^ |
| 5    | + - \| ^         |
| 4    | == != < <= >= >  |
| 3    | <-               |
| 2`   | &&               |
| 1    | \|\|             |


当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。


